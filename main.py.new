from fastapi import FastAPI, WebSocket, WebSocketDisconnect, Cookie, Query
from fastapi.responses import HTMLResponse
import uvicorn
from typing import List, Dict
import json
import base64
from datetime import datetime
import mimetypes

app = FastAPI()

# Store messages in memory
messages = []
MAX_MESSAGES = 100  # Keep last 100 messages
MAX_FILE_SIZE = 5 * 1024 * 1024  # 5MB max file size

html = """
<!DOCTYPE html>
<html>
<head>
    <title>Simple Messenger</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; max-width: 800px; margin: 0 auto; }
        .status { color: green; margin-bottom: 10px; }
        .chat-container { 
            width: 100%; 
            height: 400px; 
            border: 1px solid #ccc; 
            margin-bottom: 10px; 
            overflow-y: auto;
            padding: 10px;
            background: #f9f9f9;
        }
        .message {
            margin-bottom: 8px;
            padding: 5px;
        }
        .message .username {
            font-weight: bold;
            color: #2c5282;
        }
        .message .time {
            color: #666;
            font-size: 0.8em;
            margin-left: 5px;
        }
        .system-message {
            color: #666;
            font-style: italic;
        }
        .input-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            align-items: center;
        }
        .input-container input[type="text"] {
            flex-grow: 1;
            padding: 5px;
        }
        .file-upload {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }
        .file-upload input[type="file"] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }
        .video-container { 
            margin-top: 20px;
            display: flex;
            gap: 20px;
        }
        video { 
            background: #eee;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button { 
            padding: 5px 15px;
            background: #4299e1;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }
        button:hover {
            background: #3182ce;
        }
        .message .file-content {
            margin-top: 10px;
        }
        .message .file-content img {
            max-width: 300px;
            max-height: 200px;
            border-radius: 4px;
        }
        .message .file-content .file-download {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 5px 10px;
            background: #f0f0f0;
            border-radius: 4px;
            text-decoration: none;
            color: #2c5282;
        }
        .message .file-content .file-download:hover {
            background: #e0e0e0;
        }
        .file-icon {
            width: 16px;
            height: 16px;
            display: inline-block;
            margin-right: 5px;
        }
        .error {
            color: #e53e3e;
            padding: 10px;
            margin: 10px 0;
            background: #fff5f5;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>WebSocket Messenger + Call</h1>
    <div id="status" class="status">Connecting...</div>
    <div id="chat" class="chat-container"></div>
    <div class="input-container">
        <input id="messageInput" type="text" autocomplete="off" placeholder="Type your message..."/>
        <div class="file-upload">
            <button type="button">
                <svg class="file-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                    <path d="M12 5v13M5 12l7-7 7 7" stroke-width="2" stroke-linecap="round"/>
                </svg>
                Attach
            </button>
            <input type="file" id="fileInput" onchange="handleFileSelect(event)"/>
        </div>
        <button onclick="sendMessage()">Send</button>
        <button onclick="startCall()">Call</button>
    </div>
    <div id="fileInfo"></div>
    <div class="video-container">
        <video id="localVideo" autoplay muted playsinline width="320"></video>
        <video id="remoteVideo" autoplay playsinline width="320"></video>
    </div>
    <script type="text/javascript">
        "use strict";
        
        // Global variables
        let ws = null;
        let pc = null;
        let localStream = null;
        let reconnectAttempts = 0;
        let selectedFile = null;
        const MAX_RECONNECT_ATTEMPTS = 5;

        // Initialize everything when the page loads
        (function init() {
            try {
                const username = new URLSearchParams(window.location.search).get('username');
                if (!username) {
                    window.location.href = '/';
                    return;
                }
                initializeWebSocket(username);
            } catch (error) {
                console.error('Initialization error:', error);
                document.getElementById("status").textContent = "Error initializing - Please refresh";
            }
        })();

        // WebSocket Functions
        function initializeWebSocket(username) {
            try {
                if (ws) {
                    ws.close();
                }
                
                ws = new WebSocket(`ws://${location.host}/ws/${encodeURIComponent(username)}`);
                
                ws.onclose = function() {
                    if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                        document.getElementById("status").textContent = 
                            `Disconnected - Reconnecting... (${reconnectAttempts + 1}/${MAX_RECONNECT_ATTEMPTS})`;
                        reconnectAttempts++;
                        setTimeout(() => initializeWebSocket(username), 1000);
                    } else {
                        document.getElementById("status").textContent = "Connection failed - Please refresh";
                    }
                };

                ws.onopen = function() {
                    document.getElementById("status").textContent = "Connected";
                    console.log("WebSocket connected");
                    reconnectAttempts = 0;
                };
                
                ws.onerror = function(e) {
                    document.getElementById("status").textContent = "Error - Check console";
                    console.error("WebSocket error:", e);
                };

                ws.onmessage = handleWebSocketMessage;
            } catch (error) {
                console.error("WebSocket initialization error:", error);
                document.getElementById("status").textContent = "Connection error - Please refresh";
            }
        }

        // Message Handling Functions
        function handleWebSocketMessage(event) {
            try {
                const msg = JSON.parse(event.data);
                if (msg.type === "chat") {
                    handleChatMessage(msg);
                } else if (msg.type === "file") {
                    handleFileMessage(msg);
                } else if (msg.type === "signal") {
                    handleSignaling(msg.data);
                }
            } catch (error) {
                console.error("Message parsing error:", error);
            }
        }

        function handleChatMessage(msg) {
            try {
                const chat = document.getElementById("chat");
                const messageDiv = document.createElement("div");
                messageDiv.className = "message";

                if (msg.data.username && msg.data.message) {
                    messageDiv.innerHTML = `
                        <span class="username">${escapeHtml(msg.data.username)}</span>
                        <span class="time">${msg.data.timestamp}</span>
                        <div class="content">${escapeHtml(msg.data.message)}</div>
                    `;
                } else {
                    messageDiv.className += " system-message";
                    messageDiv.textContent = `${msg.data.username} ${msg.data.message}`;
                }
                
                chat.appendChild(messageDiv);
                chat.scrollTop = chat.scrollHeight;
            } catch (error) {
                console.error("Error handling chat message:", error);
            }
        }

        function handleFileMessage(msg) {
            try {
                const chat = document.getElementById("chat");
                const messageDiv = document.createElement("div");
                messageDiv.className = "message";
                const fileData = msg.data;

                messageDiv.innerHTML = `
                    <span class="username">${escapeHtml(fileData.username)}</span>
                    <span class="time">${fileData.timestamp}</span>
                    <div class="content">
                        ${fileData.message ? `<div>${escapeHtml(fileData.message)}</div>` : ''}
                        <div class="file-content">
                `;

                if (fileData.fileType.startsWith('image/')) {
                    messageDiv.querySelector('.file-content').innerHTML += `
                        <img src="data:${fileData.fileType};base64,${fileData.data}" 
                             alt="${escapeHtml(fileData.filename)}"
                             loading="lazy"/>
                    `;
                }

                const downloadLink = document.createElement('a');
                downloadLink.className = 'file-download';
                downloadLink.href = `data:${fileData.fileType};base64,${fileData.data}`;
                downloadLink.download = fileData.filename;
                downloadLink.innerHTML = `
                    ${getFileIcon(fileData.fileType)}
                    ${escapeHtml(fileData.filename)} (${formatFileSize(fileData.size)})
                `;

                messageDiv.querySelector('.file-content').appendChild(downloadLink);
                messageDiv.querySelector('.file-content').innerHTML += '</div>';
                chat.appendChild(messageDiv);
                chat.scrollTop = chat.scrollHeight;
            } catch (error) {
                console.error("Error handling file message:", error);
            }
        }

        // File Handling Functions
        function handleFileSelect(event) {
            try {
                const file = event.target.files[0];
                if (!file) return;

                const fileInfo = document.getElementById('fileInfo');
                
                if (file.size > 5 * 1024 * 1024) {
                    fileInfo.textContent = 'Error: File size must be less than 5MB';
                    event.target.value = '';
                    selectedFile = null;
                    return;
                }

                selectedFile = file;
                fileInfo.textContent = `Selected: ${file.name} (${formatFileSize(file.size)})`;
                
                if (file.type.startsWith('image/')) {
                    sendFile(file);
                } else {
                    document.getElementById('messageInput').placeholder = 'Add a message with your file (optional)...';
                }
            } catch (error) {
                console.error("Error handling file select:", error);
                document.getElementById('fileInfo').textContent = 'Error processing file';
            }
        }

        async function sendFile(file) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                document.getElementById("status").textContent = "Not connected - File not sent";
                return;
            }

            try {
                const message = document.getElementById('messageInput').value.trim();
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    try {
                        const base64Data = e.target.result.split(',')[1];
                        const fileData = {
                            type: 'file',
                            data: {
                                filename: file.name,
                                fileType: file.type,
                                size: file.size,
                                data: base64Data,
                                message: message
                            }
                        };
                        
                        ws.send(JSON.stringify(fileData));
                        
                        document.getElementById('fileInput').value = '';
                        document.getElementById('messageInput').value = '';
                        document.getElementById('messageInput').placeholder = 'Type your message...';
                        document.getElementById('fileInfo').textContent = '';
                        selectedFile = null;
                    } catch (error) {
                        console.error("Error preparing file data:", error);
                    }
                };
                
                reader.readAsDataURL(file);
            } catch (error) {
                console.error("Error sending file:", error);
                document.getElementById('fileInfo').textContent = 'Error sending file';
            }
        }

        function getFileIcon(fileType) {
            if (fileType.startsWith('image/')) {
                return `<svg class="file-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                    <circle cx="8.5" cy="8.5" r="1.5"></circle>
                    <polyline points="21 15 16 10 5 21"></polyline>
                </svg>`;
            } else if (fileType === 'application/pdf') {
                return `<svg class="file-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                    <polyline points="14 2 14 8 20 8"></polyline>
                    <line x1="16" y1="13" x2="8" y2="13"></line>
                    <line x1="16" y1="17" x2="8" y2="17"></line>
                    <polyline points="10 9 9 9 8 9"></polyline>
                </svg>`;
            }
            return `<svg class="file-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
            </svg>`;
        }

        // Chat Functions
        function sendMessage() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                document.getElementById("status").textContent = "Not connected - Message not sent";
                return;
            }

            try {
                if (selectedFile) {
                    sendFile(selectedFile);
                } else {
                    const input = document.getElementById("messageInput");
                    const text = input.value.trim();
                    if (text) {
                        ws.send(JSON.stringify({type: "chat", data: text}));
                        input.value = "";
                    }
                }
            } catch (error) {
                console.error("Error sending message:", error);
            }
        }

        // Utility Functions
        function escapeHtml(unsafe) {
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
            else return (bytes / 1048576).toFixed(1) + ' MB';
        }

        // WebRTC Functions
        async function startCall() {
            try {
                pc = new RTCPeerConnection();
                localStream = await navigator.mediaDevices.getUserMedia({video: true, audio: true});
                
                localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
                document.getElementById("localVideo").srcObject = localStream;

                pc.onicecandidate = ({candidate}) => {
                    if (candidate) {
                        ws.send(JSON.stringify({type: "signal", data: {candidate}}));
                    }
                };

                pc.ontrack = (event) => {
                    document.getElementById("remoteVideo").srcObject = event.streams[0];
                };

                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                ws.send(JSON.stringify({type: "signal", data: {offer}}));
            } catch (error) {
                console.error("Error starting call:", error);
            }
        }

        async function handleSignaling(data) {
            try {
                if (data.offer) {
                    if (!pc) {
                        pc = new RTCPeerConnection();
                        pc.onicecandidate = ({candidate}) => {
                            if (candidate) {
                                ws.send(JSON.stringify({type: "signal", data: {candidate}}));
                            }
                        };
                        
                        pc.ontrack = (event) => {
                            document.getElementById("remoteVideo").srcObject = event.streams[0];
                        };

                        localStream = await navigator.mediaDevices.getUserMedia({video: true, audio: true});
                        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
                        document.getElementById("localVideo").srcObject = localStream;
                    }
                    await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    ws.send(JSON.stringify({type: "signal", data: {answer}}));
                } else if (data.answer) {
                    await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                } else if (data.candidate) {
                    await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                }
            } catch (error) {
                console.error("Signaling error:", error);
            }
        }

        // Event Listeners
        document.getElementById("messageInput").addEventListener("keypress", (e) => {
            if (e.key === "Enter") {
                sendMessage();
            }
        });
    </script>
</body>
</html>
"""

login_html = """
<!DOCTYPE html>
<html>
<head>
    <title>Login - Simple Messenger</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            margin: 0;
            background: #f0f2f5;
        }
        .login-box { 
            text-align: center; 
            padding: 30px; 
            border-radius: 8px; 
            background: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            width: 300px;
        }
        h2 {
            color: #1a73e8;
            margin-bottom: 20px;
        }
        input { 
            width: 90%;
            margin: 10px 0; 
            padding: 8px; 
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        input:focus {
            outline: none;
            border-color: #1a73e8;
        }
        button { 
            width: 100%;
            padding: 10px; 
            background: #1a73e8;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
        }
        button:hover {
            background: #1557b0;
        }
        .error {
            color: #d93025;
            margin-top: 10px;
            display: none;
        }
    </style>
</head>
<body>
    <div class="login-box">
        <h2>Enter Username</h2>
        <form onsubmit="return login(event)">
            <input type="text" id="username" required minlength="3" maxlength="15" 
                   pattern="[A-Za-z0-9]+" placeholder="Choose a username"
                   title="Letters and numbers only, 3-15 characters"/>
            <div id="error" class="error"></div>
            <button type="submit">Join Chat</button>
        </form>
    </div>
    <script>
        function login(event) {
            try {
                event.preventDefault();
                const username = document.getElementById('username').value.trim();
                const error = document.getElementById('error');
                
                if (!username) {
                    error.textContent = 'Please enter a username';
                    error.style.display = 'block';
                    return false;
                }
                
                if (username.length < 3) {
                    error.textContent = 'Username must be at least 3 characters';
                    error.style.display = 'block';
                    return false;
                }
                
                if (username.length > 15) {
                    error.textContent = 'Username must be less than 15 characters';
                    error.style.display = 'block';
                    return false;
                }
                
                if (!/^[A-Za-z0-9]+$/.test(username)) {
                    error.textContent = 'Username can only contain letters and numbers';
                    error.style.display = 'block';
                    return false;
                }
                
                window.location.href = '/?username=' + encodeURIComponent(username);
                return false;
            } catch (error) {
                console.error('Login error:', error);
                return false;
            }
        }
        
        document.getElementById('username').addEventListener('input', function() {
            document.getElementById('error').style.display = 'none';
        });
    </script>
</body>
</html>
"""

class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[str, WebSocket] = {}  # username -> websocket
        self.user_sessions: Dict[WebSocket, str] = {}  # websocket -> username

    async def connect(self, websocket: WebSocket, username: str):
        await websocket.accept()
        self.active_connections[username] = websocket
        self.user_sessions[websocket] = username
        # Send connection message
        await self.broadcast_message(username, "joined the chat")
        # Send message history
        await self.send_history(websocket)

    def disconnect(self, websocket: WebSocket):
        if websocket in self.user_sessions:
            username = self.user_sessions[websocket]
            del self.active_connections[username]
            del self.user_sessions[websocket]
            return username
        return None

    async def send_history(self, websocket: WebSocket):
        for msg in messages:
            await websocket.send_text(json.dumps(msg))

    async def broadcast_message(self, username: str, message: str):
        timestamp = datetime.now().strftime("%H:%M:%S")
        msg_data = {
            "type": "chat",
            "data": {
                "username": username,
                "message": message,
                "timestamp": timestamp
            }
        }
        # Store message in history
        messages.append(msg_data)
        if len(messages) > MAX_MESSAGES:
            messages.pop(0)
        # Broadcast to all
        msg_str = json.dumps(msg_data)
        for connection in self.active_connections.values():
            await connection.send_text(msg_str)

    async def broadcast_file(self, username: str, file_data: dict):
        timestamp = datetime.now().strftime("%H:%M:%S")
        if file_data.get('size', 0) > MAX_FILE_SIZE:
            return False
        
        msg_data = {
            "type": "file",
            "data": {
                **file_data,
                "username": username,
                "timestamp": timestamp
            }
        }
        
        # Store in message history
        messages.append(msg_data)
        if len(messages) > MAX_MESSAGES:
            messages.pop(0)
            
        # Broadcast to all
        msg_str = json.dumps(msg_data)
        for connection in self.active_connections.values():
            await connection.send_text(msg_str)
        return True

    async def broadcast_signal(self, username: str, signal_data: dict):
        signal_msg = {
            "type": "signal",
            "data": signal_data,
            "username": username
        }
        signal_str = json.dumps(signal_msg)
        for other_username, connection in self.active_connections.items():
            if other_username != username:
                await connection.send_text(signal_str)

manager = ConnectionManager()

@app.get("/")
async def get(username: str = Query(None)):
    if not username:
        return HTMLResponse(login_html)
    return HTMLResponse(html)

@app.websocket("/ws/{username}")
async def websocket_endpoint(websocket: WebSocket, username: str):
    await manager.connect(websocket, username)
    try:
        while True:
            data = await websocket.receive_text()
            msg = json.loads(data)
            if msg["type"] == "chat":
                await manager.broadcast_message(username, msg["data"])
            elif msg["type"] == "signal":
                await manager.broadcast_signal(username, msg["data"])
            elif msg["type"] == "file":
                success = await manager.broadcast_file(username, msg["data"])
                if not success:
                    await websocket.send_text(json.dumps({
                        "type": "error",
                        "data": "File too large. Maximum size is 5MB."
                    }))
    except WebSocketDisconnect:
        username = manager.disconnect(websocket)
        if username:
            await manager.broadcast_message(username, "left the chat")

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)
