"""
FastAPI backend for a simple web-based messenger with WebSocket support for chat,
file sharing, and WebRTC video/audio calls.
"""

from fastapi import FastAPI, WebSocket, WebSocketDisconnect, Query, Request
from fastapi.responses import HTMLResponse, RedirectResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from starlette.middleware.cors import CORSMiddleware
from datetime import datetime
from pathlib import Path
import json
import base64
import uvicorn
import os

app = FastAPI()

# Enable CORS for production
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, replace with your domain
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Mount static files
static_path = Path(__file__).parent / "static"
app.mount("/static", StaticFiles(directory=str(static_path)), name="static")

# Setup Jinja2 templates
templates = Jinja2Templates(directory="templates")

# Store messages in memory
messages = []
MAX_MESSAGES = 100  # Keep last 100 messages
MAX_FILE_SIZE = 5 * 1024 * 1024  # 5MB max file size

class ConnectionManager:
    def __init__(self):
        self.active_connections: dict[str, WebSocket] = {}
        
    async def connect(self, websocket: WebSocket, username: str) -> None:
        if username in self.active_connections:
            await websocket.close(code=1008, reason="Username already in use")
            return
        await websocket.accept()
        self.active_connections[username] = websocket
        await self.broadcast_system_message(username, "joined the chat")
        
    def disconnect(self, websocket: WebSocket) -> str:
        username = None
        for user, conn in list(self.active_connections.items()):
            if conn == websocket:
                username = user
                del self.active_connections[user]
                break
        return username
        
    async def broadcast_system_message(self, username: str, message: str) -> None:
        msg_data = {
            "type": "system",
            "content": f"{username} {message}",
            "timestamp": datetime.now().isoformat()
        }
        await self._broadcast_to_all(msg_data)
            
    async def broadcast_message(self, username: str, content: str) -> None:
        msg_data = {
            "type": "message",
            "username": username,
            "content": content,
            "timestamp": datetime.now().isoformat()
        }
        await self._broadcast_to_all(msg_data)
        
    async def broadcast_file(self, username: str, file_data: dict) -> bool:
        try:
            file_size = len(base64.b64decode(file_data["content"].split(",")[1]))
            if file_size > MAX_FILE_SIZE:
                return False
                
            msg_data = {
                "type": "file",
                "username": username,
                "content": file_data["content"],
                "filename": file_data["filename"],
                "mimetype": file_data["type"],
                "timestamp": datetime.now().isoformat()
            }
            await self._broadcast_to_all(msg_data)
            return True
        except Exception as e:
            print(f"Error broadcasting file: {e}")
            return False
            
    async def broadcast_typing_notification(self, username: str, is_typing: bool) -> None:
        msg_data = {
            "type": "typing",
            "username": username,
            "isTyping": is_typing,
            "timestamp": datetime.now().isoformat()
        }
        for user, connection in self.active_connections.items():
            if user != username:  # Don't send typing notification to self
                await connection.send_text(json.dumps(msg_data))

    async def broadcast_signal(self, username: str, signal_data: dict) -> None:
        msg_data = {
            "type": "signal",
            "username": username,
            "signal": signal_data,
            "timestamp": datetime.now().isoformat()
        }
        # Only send to other users
        for user, connection in self.active_connections.items():
            if user != username:
                await connection.send_text(json.dumps(msg_data))

    async def _broadcast_to_all(self, msg_data: dict) -> None:
        """Broadcasts a message to all connected users and stores it in history."""
        if msg_data["type"] not in ["system", "message", "file"]:
            return

        global messages
        messages.append(msg_data)
        # Keep only the last MAX_MESSAGES
        if len(messages) > MAX_MESSAGES:
            messages = messages[-MAX_MESSAGES:]
            
        msg_str = json.dumps(msg_data)
        for connection in self.active_connections.values():
            try:
                await connection.send_text(msg_str)
            except WebSocketDisconnect:
                continue
            except Exception as e:
                print(f"Error sending message: {e}")
                continue

manager = ConnectionManager()

@app.get("/", response_class=HTMLResponse)
async def get_home(request: Request, lang: str = Query("en")):
    """Render the login page."""
    if lang not in ["en", "fa"]:
        lang = "en"
    
    # Load language file
    with open(f"static/i18n/{lang}.json", "r", encoding="utf-8") as f:
        i18n = json.load(f)
    
    return templates.TemplateResponse("login.html", {
        "request": request,
        "title": "Login - Simple Messenger",
        "lang": lang,
        "i18n": i18n
    })

@app.get("/chat", response_class=HTMLResponse)
async def get_chat(
    request: Request,
    username: str = Query(...),
    lang: str = Query("en")
):
    """Render the chat page."""
    if not username:
        return RedirectResponse(url="/")
    
    if lang not in ["en", "fa"]:
        lang = "en"
    
    # Load language file
    with open(f"static/i18n/{lang}.json", "r", encoding="utf-8") as f:
        i18n = json.load(f)
    
    return templates.TemplateResponse("chat.html", {
        "request": request,
        "username": username,
        "title": "Chat - Simple Messenger",
        "lang": lang,
        "i18n": i18n
    })

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket, username: str = Query(...)):
    """Handle WebSocket connections."""
    try:
        await manager.connect(websocket, username)
        # Send message history to new user
        for msg in messages:
            await websocket.send_text(json.dumps(msg))
        
        # Handle incoming messages
        while True:
            try:
                data = await websocket.receive_json()
                if data["type"] == "message":
                    await manager.broadcast_message(username, data["content"])
                elif data["type"] == "file":
                    success = await manager.broadcast_file(username, data)
                    if not success:
                        await websocket.send_text(json.dumps({
                            "type": "error",
                            "content": "File too large (max 5MB)"
                        }))
                elif data["type"] == "typing":
                    await manager.broadcast_typing_notification(username, data["isTyping"])
                elif data["type"] == "signal":
                    await manager.broadcast_signal(username, data["signal"])
            except json.JSONDecodeError:
                await websocket.send_text(json.dumps({
                    "type": "error",
                    "content": "Invalid message format"
                }))
                continue
            except Exception as e:
                print(f"Error processing message from {username}: {e}")
                continue
                
    except WebSocketDisconnect:
        username = manager.disconnect(websocket)
        if username:
            await manager.broadcast_system_message(username, "left the chat")
    except Exception as e:
        print(f"WebSocket error for {username}: {e}")
        try:
            await websocket.close(code=1011, reason="Internal server error")
        except:
            pass

if __name__ == "__main__":
    port = int(os.environ.get("PORT", 8000))
    host = os.environ.get("HOST", "0.0.0.0")
    uvicorn.run("main:app", host=host, port=port, reload=True)
